//This is my Main
package com.example1;
import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import parser.FixedWidthParser;

public class Main {

    private static final String MODEL_PACKAGE="model";
    public static void main(String[] args) throws IOException {

        String bankDirPath = "Bank";
        File bankDir = new File(bankDirPath);
        Map<String, List<File>> dateToFileMap = new TreeMap<>();

        for (File file : bankDir.listFiles((dir, name) -> name.endsWith(".txt"))) {
            String header = Files.lines(file.toPath()).findFirst().orElse(null);
            if (header != null && header.startsWith("HDR|")) {
                String[] parts = header.split("\\|");
                if (parts.length >= 3) {
                    String dateStr = parts[2];
                    dateToFileMap.computeIfAbsent(dateStr, k -> new ArrayList<>()).add(file);
                }
            }
        }

        for(Map.Entry<String,List<File>> entry : dateToFileMap.entrySet()){
            String dateStr = entry.getKey();
            List<File> files = entry.getValue();

            LocalDate date = LocalDate.parse(dateStr,DateTimeFormatter.ofPattern("yyyyMMdd"));
            String folderName="Control" + date.getMonth().name().substring(0,1).toUpperCase()+date.getMonth().name().substring(1).toLowerCase()+date.getDayOfMonth();
            Path targetDir = Paths.get("Control", folderName);
            Files.createDirectories(targetDir);

            for(File file:files){
                Path targetFile = targetDir.resolve(file.getName());
                Files.copy(file.toPath(),targetFile,StandardCopyOption.REPLACE_EXISTING);
            }

            for(File file:files){
                System.out.println("\nProcessing file: "+file.getName());
                List<String> lines = Files.readAllLines(file.toPath());
                List<String> dataLines = lines.subList(1,lines.size()-1);
                String fileName = lines.get(0).split("\\|")[1];
                String baseName = fileName.replaceAll("\\d+$","");
                String className = MODEL_PACKAGE+"."+baseName;

                try {
                    Class<?> modelClass = Class.forName(className);
                    List<Object> details = new ArrayList<>();

                    for(String line: dataLines){
                        try{
                            Object parsed = FixedWidthParser.parseLine(line,modelClass);
                            details.add(parsed);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println("Parsed "+ details.size()+" records:");
                } catch (ClassNotFoundException e) {
                    System.out.println("No model class found for: "+ className);
                }
            }
        }

    }
}

//This is my FixedFieldAnnotations
package annotations;
import java.lang.annotation.*;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface FixedFieldAnnotations {
    int length();
    String pattern() default "";
    boolean required() default true;
    String allowedValues() default "";
    String format() default "";
}

//This is my AccountDetails java records
package model;
import annotations.FixedFieldAnnotations;

import java.math.BigDecimal;

public record AccountDetails (
    @FixedFieldAnnotations(length = 5,format="\\d{5}")
     String customerId,
    @FixedFieldAnnotations(length = 20 , pattern="^[A-Za-z]+$")
     String customerName,
    @FixedFieldAnnotations(length = 11,format = "\\d{11}")
     String accountNumber,
    @FixedFieldAnnotations(length = 10,allowedValues = "Savings,Current")
     String accountType,
    @FixedFieldAnnotations(length = 12,format = "\\d{1,9}\\.\\d{2}")
    BigDecimal currentBalance
){}

//This is my Customer Details java records
package model;

import annotations.FixedFieldAnnotations;
public record CustomerDetails(
    @FixedFieldAnnotations(length = 5,format = "\\d{5}")
     String customerId,
    @FixedFieldAnnotations(length = 20 , pattern="^[A-Za-z]+$")
     String customerName,
    @FixedFieldAnnotations(length = 6,allowedValues = "Male,Female,Others")
     String gender,
    @FixedFieldAnnotations(length = 8,format = "\\d{2}\\d{2}\\d{4}")
     String dateOfBirth,
    @FixedFieldAnnotations(length = 10,format = "\\d{10}")
     String contactNumber,
    @FixedFieldAnnotations(length = 30,format = ".+@.+\\..+")
     String email,
    @FixedFieldAnnotations(length = 30)
     String residentialAddress
){}

//This is my LoanDetails java records
package model;
import annotations.FixedFieldAnnotations;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public record LoanDetails (
    @FixedFieldAnnotations(length = 5,format = "\\d{5}")
     String customerId,
    @FixedFieldAnnotations(length = 20, pattern="^[A-Za-z]+$" )
     String customerName,
    @FixedFieldAnnotations(length = 6,format = "\\d{6}")
     String loanId,
    @FixedFieldAnnotations(length = 12,format = "\\d{1,9}\\.\\d{2}")
    BigDecimal loanAmount,
    @FixedFieldAnnotations(length = 20,allowedValues = "Home Loan,Educational Loan,Business Loan,Personal Loan")
     String loanType,
    @FixedFieldAnnotations(length = 8,format = "\\d{8}")
     LocalDate approvalDate
    ){}

//This is my TransactionDetails java records
package model;
import annotations.FixedFieldAnnotations;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

public record TransactionDetails (

    @FixedFieldAnnotations(length = 5,format = "\\d{5}")
    String customerId,
    @FixedFieldAnnotations(length = 20 , pattern="^[A-Za-z]+$")
    String customerName,
    @FixedFieldAnnotations(length = 6,format = "\\d{6}")
    String transactionId,
    @FixedFieldAnnotations(length = 11,format = "\\d{11}")
    String accountNumber,
    @FixedFieldAnnotations(length = 30,allowedValues = "UPI,mobile wallets,digital cards,NEFT,RTGS,IMPS,Cheque,Direct Deposit,ATM Transactions")
    String transactionType,
    @FixedFieldAnnotations(length = 12,format = "\\d{1,9}\\.\\d{2}")
    BigDecimal transactionAmount,
    @FixedFieldAnnotations(length = 18,format = "\\d{2}\\d{2}\\d{4} \\d{2}:\\d{2}:\\d{1,2}")
    String transactionDateTime
){}

//This is my FixedWidthParser
package parser;
import annotations.FixedFieldAnnotations;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class FixedWidthParser {

    public static <T> T parseLine(String line, Class<T> clazz) throws Exception {
        List<Object> fieldValues=new ArrayList<>();
        int currentIndex = 0;
        for (Field field : clazz.getDeclaredFields()) {
            FixedFieldAnnotations annotation = field.getAnnotation(FixedFieldAnnotations.class);
            if (annotation != null) {
                int length = annotation.length();
                if (currentIndex + length > line.length()) {
                    throw new Exception("Line too short for field: " + field.getName());
                }

                String value = line.substring(currentIndex, currentIndex + length).trim();
                currentIndex += length;

                if (annotation.required() && value.isEmpty()) {
                    throw new Exception("Missing required field: " + field.getName());
                }

                if (!annotation.allowedValues().isEmpty()) {
                    String[] allowed = annotation.allowedValues().split(",");
                    boolean match = false;
                    for (String a : allowed) {
                        if (a.equalsIgnoreCase(value)) {
                            match = true;
                            break;
                        }
                    }
                    if (!match) {
                        throw new Exception("Invalid value for field '" + field.getName() + "': " + value);
                    }
                }
                if (!annotation.format().isEmpty() && !value.isEmpty()) {
                    if (!value.matches(annotation.format())) {
                        throw new Exception("Invalid format for field '" + field.getName() + "': " + value);
                    }
                }
                Object convertedValue = convertValue(value,field.getType());
                fieldValues.add(convertedValue);
            }
        }
        Class<?>[] paramTypes = new Class[fieldValues.size()];
        for(int i=0;i<fieldValues.size();i++){
            paramTypes[i]=fieldValues.get(i).getClass();
            //System.out.println(paramTypes[i]);
        }

        Constructor<T> constructor = clazz.getDeclaredConstructor(paramTypes);
        return constructor.newInstance(fieldValues.toArray());

    }

    private static Object convertValue(String value, Class<?> targetType){
        if(value==null || value.isEmpty())return null;

        try{
            if(targetType==String.class){
                return value;
            }else if(targetType==Integer.class||targetType==int.class){
                return Integer.parseInt(value);
            }else if(targetType==Long.class||targetType==long.class){
                return Long.parseLong(value);
            }else if(targetType==Double.class||targetType==double.class){
                return Double.parseDouble(value);
            }else if(targetType== BigDecimal.class){
                return new BigDecimal(value);
            }else if(targetType == LocalDate.class){
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("ddMMyyyy");
                return LocalDate.parse(value,formatter);
            }else if(targetType== LocalDateTime.class) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("ddMMyyyy HH:mm:ss");
                return LocalDateTime.parse(value,formatter);
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to convert value '"+ value+"'to type "+ targetType.getSimpleName(),e);
        }

        return value;
    }
}

First explain all my java code line by line and code by code, then explain the flow of my code with an example
