FileParser

- Reads and parses each line of the input file.
FixedWidthParser.parseLine(line,modelClass);
- Uses annotations to determine field lengths.

- Creates structured Java record instances.
MongoRecordMapper
Purpose:
Load all collections from MongoDB and map each document to its corresponding Java POJO class.
Key Attributes:
	Map<String, Class<?>> collectionRegistry – Maps collection names to POJO classes.
	MongoDatabase db – MongoDB database instance.
Key Methods:
	Map<String, List<?>> loadAllCollections()
o	Iterates through each collection in collectionRegistry.
o	Uses the MongoDB Java Driver to fetch all documents.
o	Converts each Document to the registered POJO class using object mapper or a custom mapper method.
o	Returns a map with collection names as keys and lists of POJOs as values.
	private <T> T mapDocumentToPojo(Document doc, Class<T> clazz)
o	Converts a single MongoDB Document into an instance of clazz.
o	Uses Java object mapper or a JSON mapping library like Jackson/Gson to bind fields.
Processing
Purpose:
Implement business logic for grouping, filtering, and organizing transaction data.
Key Methods:
	List<Transaction> filterTransactionsByCustomer(List<Transaction> transactions, int customerId)
o	Returns only the transactions where the payer or payee matches customerId.
	Map<String, List<Transaction>> groupTransactionsByDate(List<Transaction> transactions)
o	Groups transactions into a map keyed by transaction date (e.g., yyyy-MM-dd).
o	Useful for daily reports.
	Map<Integer, List<Transaction>> groupTransactionsByCustomer(List<Transaction> transactions)
o	Groups transactions by customer ID (payer or payee).
o	Returns a map keyed by customer ID.
	List<Transaction> filterTransactionsByDateRange(List<Transaction> transactions, Date start, Date end)
o	Filters transactions occurring within a specific date range.
Write In Txt
Purpose:
Write lists of POJOs into fixed-width formatted text files for easy reading or archival.
Key Methods:
	void writeTransactionsGroupedByDate(Map<String, List<Transaction>> groupedTransactions, String outputDirectory)
o	Iterates over the grouped transactions by date.
o	For each date, writes a file named transactions_YYYY-MM-DD.txt.
o	Each transaction is formatted into fixed-width columns.
	void writeTransactionsByCustomer(List<Transaction> transactions, int customerId, String outputDirectory)
o	Writes all transactions for a single customer into a dedicated text file.
o	Filename format: transactions_customer_<customerId>.txt.
	void writeGroupedTransactionsByCustomer(Map<Integer, List<Transaction>> groupedTransactions, String outputDirectory)
o	Writes multiple files, one per customer ID, containing their respective transactions.
	private String formatTransaction(Transaction txn)
o	Formats a single Transaction object into a fixed-width string line.
o	Uses spaces or padding to ensure columns align properly.
	private void ensureDirectoryExists(String path)
o	Checks if output directory exists; if not, creates it.
o	Throws a FileWriteException if directory creation fails.
Exceptions
	MappingException:
Thrown when a MongoDB document cannot be mapped to the target POJO due to missing fields or type mismatches.
	CustomerNotFoundException:
Raised when trying to process transactions or data for a non-existent customer ID.
	FileWriteException:
Raised for file I/O errors during writing, such as missing directory or insufficient permissions.
Data Flow Example
1.	Load Data
MongoRecordMapper.loadAllCollections() fetches all documents, maps them to POJOs.
2.	Process Data
Processing.groupTransactionsByDate() groups transactions by date.
Processing.filterTransactionsByCustomer() filters transactions for a specific customer.
3.	Write Output
WriteInTxt.writeTransactionsGroupedByDate() writes grouped transactions to date-based text files.
WriteInTxt.writeTransactionsByCustomer() writes customer-specific transaction history.

generate your content like this...
